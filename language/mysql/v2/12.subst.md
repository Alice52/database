## 分库分表

![avatar](/static/image/common/dist-akf.jpg)

### 简介

1. 目的

   - 性能: 切分为了减少数据库的负担, 缩短查询的时间
   - 流量

2. 条件

   - 单表的数据量达到 1000W
   - 或单表大小 100G 以后
   - 原因: 优化索引、添加从库等可能对数据库性能提升效果不明显

3. 分类

   - 分库
     1. 水平
     2. **垂直**: 将一个数据库拆分成多个{微服务下}, 根据业务将其划分为一个个的小库, 以便提高性能
   - 分表
     1. **水平**: 一张数据表使用一条水平闲将数据表划开, 将一张表的数据放入不同的地方
     2. 垂直: 一张数据表使用一条竖线闲将数据表划开, 将一个大表的字段拆分成多个小表

   ![avatar](/static/image/common/st-vertical.png)

4. 垂直划分

   - 优点: 行记录||库变小, 数据页可以存放更多记录, 在查询时减少 I/O 次数
   - 缺点
     1. 主键出现冗余, 需要管理冗余列
     2. 会引起表连接 JOIN 操作, 可以通过在业务服务器上进行 join 来减少数据库压力
     3. 依然存在单表数据量过大的问题

5. 水平划分

   - 水平划分是根据一定规则拆分数据(库), 每个数据库结构一致, 但是数据得以拆分, 从而提升性能
     - 例如时间或 id 序列值等进行数据的拆分
     - 比如根据年份来拆分不同的数据库
   - 优点: 单库(表)的数据量得以减少, 提高性能, 切分出的表结构相同, 程序改动较少
   - 缺点
     - 分片事务一致性难以解决
     - 跨节点 join 性能差, 逻辑复杂
     - 数据分片在扩容时需要迁移

### 分区表

1. 分区表是一个独立的**逻辑表**, 但是底层由多个**物理子表**组成
2. 当查询条件的数据分布在某一个分区的时候, 查询引擎只会去某一个分区查询, 而不是遍历整个表
3. 在管理层面, 如果需要删除某一个分区的数据, 只需要删除对应的分区即可
4. 分类
   - 按照范围分区: Partition by range(xx)
   - list 分区: partition by list(xx)
   - hash 分区: partition by hash(xx)

### 分布式下分库分表 Id 问题

- 防止出现`一表有难多表围观`的场景

1. 通过对 id 取模进行分表 + 保证 Id 递增
2. 根据 id 的范围进行分表{分片}
   - 会造成`一表有难多表围观`
   - 但是数据是按照时间聚集的: 很有用的标准
3. 雪花算法的变形: 通过配置可以控制输出的分库分表标识
   - 2 位分库标识
   - 2 位分表标识
4. 举例

   - tidb 是 Range 的概念进行数据表分片, 其实就是根据 id 范围进行数据库分表
   - tidb 不建议使用自增 Id, 防止 `一表有难多表围观`{所有操作数据都落在那个分片{表}上}

   ![avatar](/static/image/common/st-tidb-id.png)
