[toc]

## intros

1. join 的流程及现象

   - 流程:
     1. 左表选取一条数据, 与右表匹配, 满足条件的留下; 左表下一条匹配
     2. 多表 join 是 a join b 的结果在进行 join c
   - 索引下流程
     1. 如果可以命中索引, 就会先使用索引**过滤一下数据(连表|where 条件[会影响驱动表的选择])**`, 之后才会进行 join
     2. 如果没有则会先做 join 之后根据 where 对 join 之后的结果进行过滤
     3. 驱动表是走全表扫描, 而被驱动表是走树搜索

2. 驱动表的选择(cost 计算): 小表作为驱动表

   - 左表就一条记录, join 右表则是**顺序读**
   - 最终产生的 row 不会变化, 但是过程中时不一样的 cost: 极端的例子(驱动表 n 条, 被驱动表 1 条)
   - 优化器回去比较这两种的 cost: `scan a' cost[io+cpu] + a's rows[某个地方记录的近似值] * b's cost`
   - nlj 时间复杂度(被驱动表命中索引): N 是驱动表行数, M 是被驱动表行数
     ![avatar](/static/image/mysql/mysql-join-cost.png)
   - join 下驱动表的选择
     ```js
     如果是 Index Nested-Loop Join 算法: 应该选择小表做驱动表
     如果是 Block Nested-Loop Join 算法:
        在 join_buffer_size 足够大的时候, 是一样的
        在 join_buffer_size 不够大的时候（这种情况更常见）, 应该选择小表做驱动表
     ```
   - **在决定哪个表做驱动表的时候, 应该是两个表按照各自的条件过滤, 过滤完成之后, 计算参与 join 的各个字段的总数据量, 数据量小的那个表, 就是小表**

3. 固定驱动表(straight_join): 不要被优化改动

   ```sql
   -- t1: 100 records; t2: 1000 records; idx_a
   select * from t1 straight_join t2 on (t1.a=t2.a);           -- t1 is drived table
   select * from t2 straight_join t1 on (t1.a=t2.a);           -- t2 is drived table

   select * from t2 join t1 on (t1.a=t2.a);                    -- t1 is drived table
   select * from t1 join t2 on (t1.a=t2.a);                    -- t1 is drived table

   select * from t2 left join  t1 on (t1.a=t2.a);              -- t2 is drived table
   select * from t1 left join  t2 on (t1.a=t2.a);              -- t1 is drived table
   ```

4. left join

   - **left join 如果 where 条件中含有 table_b 的非空条件[除开 is null] 会被优化成笛卡尔积的 join, 否则按照 SQL 执行**
     1. 将 LEFT JOIN 优化为 JOIN(即笛卡尔积 JOIN)可能会带来一定的性能提升
     2. 在 nlj 中是不会产生临时表的(直接在内存中只用两个指针进行配对, 得到结果), 但是在 bnlj &smj 就会需要临时表存储数据: sort/group 引起的临时表不算此场景下
     3. left join 要没有 where 的时候全量保存驱动表: 处理的数据量就相对大一些
   - left join 的右表在 on 中可以过滤, 且 on 的执行要早于 where, 所以右表的条件尽量写在 on 中, 可以减少最终临时表的 row: 这个是在不能优化为 笛卡尔积的情况下
   - inner vs left

     1. 只是在对驱动表的数据选择上不同, inner 被驱动表无满足条件时不取, left 会保留{但是在 where 中还是可以过滤掉的}
     2. inner join b: 也是有可能出现多条数据的{1 对 n 下}

5. ~~join 算法~~

   - 嵌套循环连接: 对于左表的每一行, 都会扫描右表, 找到与左表行匹配的行. 这种方式适用于左表和右表中至少有一个表较小的情况, 但是如果右表非常大, 则会导致性能问题.
   - 排序合并连接: 对左表和右表分别进行排序, 然后进行连接操作. 这种方式适用于左表和右表都很大的情况, 但是排序操作可能会消耗很多时间和资源.
   - 哈希连接: 将左表和右表分别存储到哈希表中, 然后进行连接操作. 这种方式适用于左表和右表中至少有一个表较大的情况, 但是需要消耗较多的内存和磁盘空间

## NLJ: index Nested-Loop Join

```sql
-- t1: 100 records; t2: 1000 records; idx_a
select * from t1 straight_join t2 on (t1.a=t2.a);
```

1. 基本流程: 和嵌套子查询差不多+使用上被驱动表的索引

   - 从表 t1 中读入一行数据 R
   - 从数据行 R 中, 取出 a 字段到表 t2 里去查找；
   - 取出表 t2 中满足条件的行, 跟 R 组成一行, 作为结果集的一部分: **这一步一般是不需要临时表的(除非排序等操作)**
   - 重复执行步骤 1 到 3, 直到表 t1 的末尾循环结束.
   - 如果还有第三个参与 Join, 则再通过前两个表的 Join 结果集作为循环基础数据, 再一次通过循环查询条件到第三个表中查询数据, 如此往复

   ![avatar](/static/image/mysql/mysql-join-flow.png)

2. feature

   - 小表驱动大表所建立的连接次数也远比大表驱动小表所建立的连接次数要小的多 + **被被驱动表上创建索引**
   - inner join mysql 会自动优化大小表的顺序

3. 在被驱动表没有索引的情况下, 叫`Simple Nested-Loop Join`, 会损失大量的性能(扫描行数太多): mysql 在这个场景下使用的是 BNL 解决

## bnl(被驱动表没有索引-性能不是很好): Block Nested-Loop Join

1. 基本流程

   - 把表 t1 的数据读入线程内存 join_buffer 中, 由于我们这个语句中写的是 select \*, 因此是把整个表 t1 放入了内存
   - 扫描表 t2, 把表 t2 中的每一行取出来, 跟 join_buffer 中的数据做对比, 满足 join 条件的, 作为结果集的一部分返回

   ![avatar](/static/image/mysql/mysql-join-bnl.png)

   - 此时驱动表无所谓: 扫描行数和内存判断此时都一样

2. join buffer(默认 256k) 放不下场景流程: **分段放**

   - 扫描表 t1, 顺序读取数据行放入 join_buffer 中, 放完第 88 行 join_buffer 满了, 继续第 2 步
   - 扫描表 t2, 把 t2 中的每一行取出来, 跟 join_buffer 中的数据做对比, 满足 join 条件的, 作为结果集的一部分返回
   - 清空 join_buffer
   - 继续扫描表 t1, 顺序读取最后的 12 行数据放入 join_buffer 中, 继续执行第 2 步

   ![avatar](/static/image/mysql/mysql-join-bnl-2.png)

   - 驱动表 N(小好), 被驱动表 M: 扫描行数是 N+λ\*N\*M; 内存判断 N\*M 次
     1. k 段: λ\*N, 因此 join_buffer_size 大一些, 则 k 会小

3. feature

   - 多关联一个表, 就会多分配一个关联缓存(join_buffer_size): 如果在一个 SQL 中关联的表越多, 所占用的内存也就越大
   - join_buffer_size 参数不合理: 容易造成服务器内存溢出的情况, 影响数据库性能的稳定性

## cost 计算

1. calculate a's cost between all-scan and index: `io+cpu`

   - 全表扫描的 cost: rows \* 读取一行的 cost + 顺序读
   - 走索引的 cost: **走索引的 cost 会默认认为回表** 索引, 扫描该索引的 cost + 索引过滤后的行数 \* 回表时读取一行的 cost + 随机读

2. table_a has index of idx_a and idx_b, how to choose index

   - idx_a's cost: 扫描 idx_a 的 cost + idx_a 过滤后的行数 \* 回表时读取一行的 cost
   - idx_b's cost: 扫描 idx_b 的 cost + idx_b 过滤后的行数 \* 回表时读取一行的 cost

## optimize

1. _在多表连接情况下(数据量很多), 且此时有小表时, 则可以考虑将小表直接加载到内存中进行逻辑操作_
   - 否则 join 小表会产生大量的数据
2. nlj 性能没啥大问题, bnl 性能稍差
3. 被驱动表是大表, 且是冷数据, 执行时影响
   - io
   - 内存内的热数据会被 lru 策略驱除或前移: 导致内存命中率低, 业务变慢(阻塞)

## reference

1. [join - 简介](https://mp.weixin.qq.com/s/yAPPQFWJ9NDHw1ck4MDvvQ)
2. [join - 实现](https://time.geekbang.org/column/article/79700)
3. [join - 优化](https://time.geekbang.org/column/article/80147)
4. [join - 优化](https://mp.weixin.qq.com/s?__biz=MzIwNjg4MzY4NA==&mid=2247485569&idx=1&sn=d6bc6678078a6c004dfa6d105e6bbda2)
5. [join](https://github.com/Alice52/java-ocean/issues/149)
