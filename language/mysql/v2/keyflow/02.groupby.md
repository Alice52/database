## [group by](https://github.com/alice52/java-ocean/issues/154)

```sql
create table t_group_by (
  id int unsigned auto_increment primary key,
  i1 int unsigned default '0'  null,
  c1 char(11)      default ''   null,
  e1 enum ('北京', '上海', '广州', '深圳', '天津', '杭州', '成都', '重庆', '苏州', '南京', '洽尔滨', '沈阳', '长春', '厦门', '福州', '南昌', '泉州', '德清', '长沙', '武汉') default '北京' null,
  d1 decimal(10, 2) null
) charset = utf8;
create index idx_e1_i1 on t_group_by (e1, i1);

INSERT INTO t_group_by (id, i1, c1, e1, d1) VALUES (1, 11, '11 测试char', '深圳', 156.15);
INSERT INTO t_group_by (id, i1, c1, e1, d1) VALUES (2, 12, '12 测试char', '深圳', 165.54);
INSERT INTO t_group_by (id, i1, c1, e1, d1) VALUES (3, 13, '13 测试char', '深圳', 156.40);
INSERT INTO t_group_by (id, i1, c1, e1, d1) VALUES (4, 14, '14 测试char', '深圳', 65.45);
INSERT INTO t_group_by (id, i1, c1, e1, d1) VALUES (5, 15, '15 测试char', '深圳', 45.70);
INSERT INTO t_group_by (id, i1, c1, e1, d1) VALUES (6, 16, '16 测试char', '成都', 1564.40);
INSERT INTO t_group_by (id, i1, c1, e1, d1) VALUES (7, 17, '17 测试char', '南京', 15.15);
INSERT INTO t_group_by (id, i1, c1, e1, d1) VALUES (8, 18, '18 测试char', '南京', 156.45);
INSERT INTO t_group_by (id, i1, c1, e1, d1) VALUES (9, 19, '19 测试char', '南京', 65.50);
INSERT INTO t_group_by (id, i1, c1, e1, d1) VALUES (10, 20, '20 测试char', '德清', 65.55);
```

### 简介: `组+能取的字段+聚合+过滤`

1. 分组

   - group by 后面有多个字段时则多个字段完全相同则为一组

2. 能取的字段

   - 通常, 选定的列必须包含在 group by 中: 如果 group by a, 有两列数据 a 列相同, 那么 select 其他字段是非法的, 因为他的值是不确定的.
   - 如果 group-by 的是主键列, 或者是可以唯一标识一条记录的[即 group-by 之前和之后的 row-count 一样]: 对于有唯一性约束的字段, 也可以不用在 group by 中把 select 中的字段全部列出来
   - 5.7 之后可以通过参数去控制是可以获取*非法字段*: `only_full_group_by`

   ```sql
   select @@sql_mode;
   set @@sql_mode = sys.list_drop(@@sql_mode, 'only_full_group_by');
   set @@sql_mode = sys.list_add(@@sql_mode, 'only_full_group_by');
   ```

3. 聚合

   - 如果在不包含 group by 子句的语句中使用组合函数, 就等效于对所有行进行分组
   - 聚合函数

     1. 方差和标准差函数会对数值参数返回 double 值
     2. sum()和 avg() 对精确值参数[integer 或 decimal]返回 decimal 值, 而对近似值参数[float 或 double]返回 double 值
     3. 时间类型的参数对 sum()和 avg()无效: 它们会把时间类型的值转换成数字, 丢弃第一个非数字字符后的所有信息

     ```sql
     min/max/sum/avg([distinct] expr) -- distinct 则用于返回 expr 的不同值的平均值 & 如果没有匹配的行, avg()返回 null
     count([distinct] expr, [expr...]) -- null 值不会被 count 统计
     group_concat([distinct] expr [,expr ...]
               [order by {unsigned_integer | col_name | expr} [asc | desc] [,col_name ...]]
               [separator str_val])  -- 分组后的拼装
     json_arrayagg(col or expr)      -- 将结果集聚合为单个json数组
     json_objectagg(key,value)       -- 返回包含键值对的json对象, 键名称为null
     ```

4. 过滤: having

   - having 子句
     1. group by 的字段
     2. 聚合函数
   - 功能:
     1. 是否存在缺失的编号: `having count(*) <> max(id) - min(id) + 1`
     2. 众数:
     3. 中位数: 非等值自连接 + sum-case-count
     4. 是否存在列值为 null: count

### 执行流程{实现}

1. [命中索引]使用[松散索引扫描]实现 group by

   - 定义:

     1. 从存储引擎读取分组记录时会**跳着**读
     2. 读取 **`分组前缀`** 后, 直接通过分组前缀定位到分组中符合 where 条件的第一条或最后一条记录, 而**不需要读取分组的所有记录**
     3. 然后就接着读取下一个分组的分组前缀, 减少 select 语句执行过程中需要读取的记录数
     4. 因此`一般`比紧凑索引扫描更快

     ![avatar](/static/image/mysql/key-groupby-loose-instance.png)

   - explain 标识: `extra: Using index for group-by`

     ![avatar](/static/image/mysql/key-groupby-loose.png)

   - 条件: `t1(c1,c2,c3,c4)-idx(c1,c2,c3)`

     1. 仅限于单表查询
     2. group by 字段必须满足索引的最左匹配原则: **where 不参与前缀**
        - 满足的: `distinct c1, c2` || `where c2 > const group by c1, c2`
        - 不满足的: `where c2='a' group by c1, c3 || where c1='a' group by c2, c3`
     3. 只能是其中一组 `max / min` || `count(distinct) / sum(distinct) / avg(distinct)`
        - 原因: 两组的分组前缀逻辑不同
        - min / max 用 `group by 字段值`作为分组前缀
        - count(distinct)/sum(distinct)/avg(distinct) 用 `group by 字段值 + 聚合函数中的字段值`作为分组前缀
     4. 使用到的索引必须是全字段索引: 不能是前缀索引

   - 执行流程: min
     ```sql
     select e1, min(i1) from t_group_by group by e1
     ```
     1. 词法分析 & 语法分析阶段: `min(i1) 被解析为 Item_sum_min 类`
     2. 查询准备阶段: 关联最小值字段为
     3. 执行阶段
        - 读取分组前缀: min/max 分组前缀为 group by 的字段
        - 根据分组前缀读取分组最小值: 使用前缀限定索引扫描访问, 获取最小值; 不会读所有值(b+tree)

2. [命中索引]使用紧凑索引扫描实现 group by

   - 定义:

     1. 以索引**范围扫描或全索引扫描**方式, 按顺序一条一条读取记录, 不会跳过中间的某条记录
     2. 读取所有满足条件的索引键, 然后再根据读取恶的数据来完成 GROUP BY 操作得到相应结果

        ![avatar](/static/image/mysql/key-groupby-tight-instance.png)

   - explain 标识: 没有 Using index for group-by 且没有 temporary

     ![avatar](/static/image/mysql/key-groupby-tight.png)

   - 条件
     1. **group by 字段包含在索引中**
     2. 满足索引最左匹配原则: where 参与前缀计算
   - 执行流程

     ```sql
     -- 紧凑索引扫描
     select e1, avg(i1) as t from t_group_by where d1>5452415 group by e1;
     -- 紧凑索引扫描
     select i1 as t from t_group_by where e1='深圳' group by i1;

     -- 临时表
     select i1 as t from t_group_by where e1>'深圳' group by i1;
     ```

     1. 词法分析 & 语法分析阶段: `avg(i1) 被解析为 Item_sum_avg 类`
     2. 查询准备阶段: 关联最小值字段为
     3. 执行阶段
        - server 层从存储引擎读取到一条记录, 判断记录是否符合 where 条件
        - 记录不符合 where 条件, 继续读取下一条记录
        - 记录符合 where 条件, 进行聚合函数逻辑处理
          1. 如果当前记录的分组前缀和上一条记录的分组前缀不一样, 说明需要结束上一个分组, 并开启新分组
             - 结束上一个分组: 通过 sum / count 计算得到分组平均值, 把分组前缀及分组平均值发送给客户端
             - 开启新分组: Item_sum_avg 类的实例属性 sum, count 清零, 当前记录的 e1 字段值作为新分组前缀, 然后新分组进行分组求和(sum 加上 i1 字段值), 分组计数(count 加 1)
          2. 如果当前记录的分组前缀和上一条记录的分组前缀一样, 说明还是同一个分组, 只需要进行分组求和、分组计数, 不需要计算平均值

3. 使用临时表实现 group by

#### 效率问题

1. 一般 `松散索引 优于 紧凑索引`

   - 在没有 where 子句{全索引扫描}, 松散索引扫描需要读取的键值数量与分组的组数量一样多{比实际存在的键值数目要少很多}
   - 在 where 子句{含范围或等值}, 松散索引扫描查找满足范围条件的每个组的第 1 个关键字, **并且再次读取尽可能最少数量的关键字**

2. 松散索引扫描成本更高

### optimize practice

1. 临时表

### group by vs order by

1. group-by 和 order-by 的关系:
   - 5.7 及之前 mysql 会对 group by 的字段进行排序: `排序后再分组是一个很快速的方式`
   - 8.0 则取消了对结果集的分组

### issue

1. `select i1 as t from t_group_by where e1='深圳' group by i1;` 为什么不能使用 loose index scan

## reference

1. [group by - 索引扫描 8.0](https://dev.mysql.com/doc/refman/8.0/en/group-by-optimization.html)
2. [group by - 索引扫描 5.7](https://mp.weixin.qq.com/s/oJ7_8Bfumw3yAUEqluK2Pg)
3. [group by - 索引扫描 summary](https://www.cnblogs.com/bonelee/p/6359250.html)
4. [group by - 实现原理](https://time.geekbang.org/column/article/80477)
5. [group by - 8.0 不在默认排序](https://dev.mysql.com/blog-archive/removal-of-implicit-and-explicit-sorting-for-group-by/)
6. [group by - aggregate 函数](https://dev.mysql.com/doc/refman/5.7/en/aggregate-functions.html)
7. [group by - having](https://mp.weixin.qq.com/s/46woqFA6VscqairFsGWXcQ)
8. [group by - select](https://blog.csdn.net/qq_24432315/article/details/108162808)
9. [group by - 临时表](https://www.jb51.net/article/147261.htm)
